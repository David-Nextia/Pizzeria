# üìö 7. State Hoisting y ViewModel compartido entre pantallas

## Objetivos de la clase

* Comprender el concepto de **State Hoisting** (elevaci√≥n del estado) en Jetpack Compose.
* Entender c√≥mo compartir un **ViewModel** entre m√∫ltiples pantallas.
* Implementar comunicaci√≥n entre pantallas: por ejemplo, **agregar pizzas a un carrito de compras**.
* Aplicar el patr√≥n **MVVM + Clean Architecture** manteniendo independencia de la UI.
* Preparar la base para la persistencia del estado (que se ver√° en la siguiente clase).

---

## 1-. Introducci√≥n: del pedido al carrito

Hasta ahora, nuestra pizzer√≠a muestra un men√∫ y un detalle por pizza.  
Pero a√∫n no tenemos c√≥mo **guardar lo que el cliente selecciona**.  
En una app real, necesitamos **compartir el estado entre pantallas**: por ejemplo, el carrito de compras debe verse tanto en el men√∫ como en la pantalla de resumen.

| Situaci√≥n en la pizzer√≠a | Equivalente en la app |
|---------------------------|-----------------------|
| El cliente elige una pizza. | El usuario da clic en una pizza del men√∫. |
| El mesero apunta el pedido. | El `ViewModel` guarda la selecci√≥n. |
| El pedido aparece en la caja y la cocina. | El estado del carrito se comparte entre pantallas. |

---

## 2-. Qu√© es State Hoisting

En Jetpack Compose, **cada Composable tiene su propio estado**, pero eso puede causar problemas si varias pantallas deben compartir la misma informaci√≥n.

**State Hoisting** significa ‚Äúelevar‚Äù el estado a un nivel superior (por ejemplo, al `ViewModel`), para que varias pantallas puedan **leerlo y modificarlo** sin perder sincronizaci√≥n.

**Principios de State Hoisting:**

1. El estado debe tener **una sola fuente de verdad (Single Source of Truth)**.  
2. Los Composables **no guardan datos importantes**, solo los muestran.  
3. El `ViewModel` mantiene y expone ese estado a las pantallas.

---

## 3-. Ampliando nuestro ViewModel

En clases anteriores, el `PizzaViewModel` ten√≠a una lista de pizzas y pod√≠a mostrar detalles.  
Ahora lo extenderemos con una lista de pizzas agregadas al carrito.

---

## 3.1-. Configuraci√≥n previa en Gradle

Antes de continuar, agrega (o verifica) las dependencias necesarias en `app/build.gradle.kts` para que funcionen la navegaci√≥n y los √≠conos que usaremos:

```kotlin
dependencies {
    implementation("androidx.navigation:navigation-compose:2.7.7")
    implementation("androidx.compose.material:material-icons-extended")
    // ...
}
```

La librer√≠a `material-icons-extended` incluye los √≠conos de flecha, carrito y borrar que aparecen en los `TopAppBar`.

---

```kotlin
class PizzaViewModel : ViewModel() {

    private val getPizzaUseCase = GetPizzaOfDayUseCase(PizzaRepositoryImpl())
    private val getAllPizzasUseCase = GetAllPizzasUseCase(PizzaRepositoryImpl())

    var pizzaOfDay by mutableStateOf(getPizzaUseCase.execute())
        private set

    var pizzaList by mutableStateOf(getAllPizzasUseCase.execute())
        private set

    // Nuevo estado: lista del carrito
    var cartItems by mutableStateOf<List<Pizza>>(emptyList())
        private set

    // Funci√≥n para agregar una pizza al carrito
    fun addToCart(pizza: Pizza) {
        cartItems = cartItems + pizza
    }

    // Funci√≥n para limpiar el carrito
    fun clearCart() {
        cartItems = emptyList()
    }
}
```

### Explicaci√≥n paso a paso

* `cartItems` mantiene la lista de pizzas seleccionadas.  
* `mutableStateOf` permite que la UI se actualice autom√°ticamente cuando cambia.  
* `addToCart()` agrega una pizza a la lista sin mutar la original (usando `+`).  
* `clearCart()` permite vaciar el carrito.

---

## 4-. Navegaci√≥n con ViewModel compartido

Queremos que **las tres pantallas compartan el mismo estado del carrito**:

* `MenuScreen` ‚Üí muestra todas las pizzas y permite agregar.  
* `PizzaDetailScreen` ‚Üí muestra detalle y bot√≥n de ‚ÄúAgregar al carrito‚Äù.  
* `CartScreen` ‚Üí muestra las pizzas agregadas.

```kotlin
@Composable
fun PizzeriaApp() {
    val navController = rememberNavController()
    val viewModel: PizzaViewModel = viewModel() // ViewModel compartido

    NavHost(navController = navController, startDestination = "menu") {
        composable("menu") { MenuScreen(navController, viewModel) }
        composable("detalle/{pizzaName}") { backStackEntry ->
            val pizzaName = backStackEntry.arguments?.getString("pizzaName")
            PizzaDetailScreen(pizzaName, viewModel, navController)
        }
        composable("carrito") {
            CartScreen(viewModel, navController)
        }
    }
}
```

### Explicaci√≥n

* `viewModel()` se crea **una sola vez** en la ra√≠z de `PizzeriaApp()`.  
* Se pasa por par√°metro a cada pantalla (`MenuScreen`, `PizzaDetailScreen`, etc).  
* As√≠, todas comparten el mismo estado (`cartItems`).
* En el men√∫ mostramos un `BadgedBox` en el √≠cono del carrito para reflejar cu√°ntos elementos lleva el usuario.

---

## 5-. Agregar pizzas desde el detalle

Ahora, en la pantalla de detalle, permitimos al usuario **agregar la pizza al carrito**.

```kotlin
@Composable
fun PizzaDetailScreen(
    pizzaName: String?,
    viewModel: PizzaViewModel,
    navController: NavController
) {
    val pizza = remember(pizzaName) { viewModel.findPizzaByName(pizzaName) }
    val cartCount = viewModel.cartItems.size
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Detalle de ${pizza?.type ?: pizzaName}") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Volver")
                    }
                },
                actions = {
                    IconButton(onClick = { navController.navigate("carrito") }) {
                        BadgedBox(
                            badge = {
                                if (cartCount > 0) {
                                    Badge { Text("$cartCount") }
                                }
                            }
                        ) {
                            Icon(Icons.Default.ShoppingCart, contentDescription = "Ir al carrito")
                        }
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            if (pizza != null) {
                Image(
                    painter = painterResource(id = pizza.imageRes),
                    contentDescription = pizza.type,
                    modifier = Modifier.size(160.dp)
                )
                Text("Precio: $${pizza.price}")
                Button(onClick = {
                    viewModel.addToCart(pizza)
                    scope.launch {
                        snackbarHostState.showSnackbar("Pizza agregada al carrito")
                    }
                }) {
                    Text("Agregar al carrito üõí")
                }
            }
        }
    }
}
```

### Explicaci√≥n

* `IconButton` con carrito permite navegar a la nueva pantalla `CartScreen`.  
* `navigationIcon` agrega la flecha para volver y el `BadgedBox` muestra cu√°ntos elementos hay en el carrito.  
* El bot√≥n **‚ÄúAgregar al carrito‚Äù** llama a `viewModel.addToCart(pizza)` y muestra un *snackbar* de confirmaci√≥n.  
* Como el estado vive en el `ViewModel`, se actualiza autom√°ticamente.  

---

## 6-. Pantalla del carrito

```kotlin
@Composable
fun CartScreen(
    viewModel: PizzaViewModel,
    navController: NavController
) {
    val cart = viewModel.cartItems
    val cartCount = cart.size

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("üõí Carrito ($cartCount)") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Volver")
                    }
                },
                actions = {
                    if (cart.isNotEmpty()) {
                        IconButton(onClick = { viewModel.clearCart() }) {
                            Icon(Icons.Default.Delete, contentDescription = "Vaciar")
                        }
                    }
                }
            )
        }
    ) { padding ->
        if (cart.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding),
                contentAlignment = Alignment.Center
            ) {
                Text("El carrito est√° vac√≠o üò¢")
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .padding(padding)
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(cart) { pizza ->
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        elevation = CardDefaults.cardElevation(4.dp)
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            Image(
                                painter = painterResource(id = pizza.imageRes),
                                contentDescription = pizza.type,
                                modifier = Modifier.size(60.dp)
                            )
                            Column {
                                Text(pizza.type, style = MaterialTheme.typography.titleMedium)
                                Text("Precio: $${pizza.price}")
                            }
                        }
                    )
                }
            }
        }
    }
}
```

### Explicaci√≥n

* Se observa la lista `cartItems` directamente desde el `ViewModel`.  
* `navigationIcon` habilita volver a la pantalla anterior reutilizando el mismo estado.  
* `TopAppBar` muestra el n√∫mero de elementos, expone la acci√≥n para vaciar y Compose recompone autom√°ticamente cuando cambia la lista.

---

## 7-. Resumen t√©cnico

| Concepto | Qu√© significa | En nuestro ejemplo |
|-----------|----------------|--------------------|
| **State Hoisting** | Elevar el estado fuera del Composable. | El carrito vive en el `ViewModel`. |
| **Single Source of Truth** | Una √∫nica fuente de datos compartida. | `cartItems` en el ViewModel. |
| **Recomposici√≥n** | Redibujo autom√°tico ante cambios. | Se actualiza el carrito en tiempo real. |
| **ViewModel compartido** | Mismo ViewModel en varias pantallas. | `MenuScreen`, `DetailScreen` y `CartScreen` usan el mismo. |

---

## 8-. Resumen de la clase

* El **estado no debe vivir en la UI**, sino en el `ViewModel`.  
* **State Hoisting** permite compartir y sincronizar datos entre pantallas.  
* **Compose** se encarga de redibujar autom√°ticamente al cambiar el estado.  
* Ahora la app puede mantener la informaci√≥n del carrito y compartirla.  
* En la pr√≥xima clase veremos **c√≥mo guardar este estado** (persistencia con `rememberSaveable` y `Room`).

> ‚ÄúEl carrito es la memoria del mesero: si el cliente cambia de mesa, el pedido sigue siendo el mismo.‚Äù

---

## Referencias

* [State in Compose - Android Developers](https://developer.android.com/jetpack/compose/state)  
* [State Hoisting in Compose](https://developer.android.com/jetpack/compose/state#state-hoisting)  
* [ViewModel & Compose integration](https://developer.android.com/topic/libraries/architecture/viewmodel)
