# üìö Clase 6: Navegaci√≥n y pantallas m√∫ltiples en Jetpack Compose
## Objetivos de la clase
- Comprender la navegaci√≥n declarativa en Compose usando `NavController` y `NavHost`.
- Construir una app de varias pantallas: Men√∫ ‚Üí Detalle.
- Pasar argumentos por ruta y recuperarlos de forma segura.
- Mantener arquitectura **MVVM + Clean Architecture** con estado en `ViewModel`.
- Practicar **state hoisting** (elevar estado) y reuso de `ViewModel` compartido.

## Requisitos previos
- Proyecto base con Material 3 y la estructura de la pizzer√≠a de clases anteriores.
- Tener agregado Navigation Compose en `build.gradle`:

```kotlin
// build.gradle (Module: app)
dependencies {
    implementation("androidx.navigation:navigation-compose:2.7.7")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
}
```

**Notas:**
- `navigation-compose` proporciona `NavController`, `NavHost` y `composable`.
- `lifecycle-viewmodel-compose` permite obtener `ViewModel` dentro de composables.

## 1. Estructura del grafo de navegaci√≥n

```kotlin
@Composable
fun PizzeriaApp() {
    val navController = rememberNavController()

    NavHost(
        navController = navController,
        startDestination = "menu"
    ) {
        composable(route = "menu") {
            MenuScreen(navController)
        }
        composable(route = "detalle/{pizzaName}") { backStackEntry ->
            val pizzaName = backStackEntry.arguments?.getString("pizzaName")
            PizzaDetailScreen(pizzaName)
        }
    }
}
```

**Qu√© est√° pasando (paso a paso):**
- `rememberNavController()` crea un objeto que sabe **a qu√© pantalla** estamos y **a cu√°l navegar**.
- `NavHost` recibe el `navController` y define pantallas con `composable("ruta")`.
- `{pizzaName}` es un **placeholder** que se reemplaza por el valor real cuando naveguemos.

## 2. Pantalla de Men√∫ con navegaci√≥n al detalle

```kotlin
@Composable
fun MenuScreen(
    navController: NavController,
    viewModel: PizzaViewModel = viewModel()
) {
    val pizzas = viewModel.pizzaList

    Scaffold(
        topBar = { TopAppBar(title = { Text("Men√∫ de Pizzas") }) }
    ) { padding ->
        LazyColumn(contentPadding = padding) {
            items(pizzas) { pizza ->
                PizzaItem(pizza = pizza) {
                    navController.navigate("detalle/${pizza.type}")
                }
            }
        }
    }
}
```

**Notas para alumnos:**
- `LazyColumn` renderiza listas grandes eficientemente.
- `PizzaItem` recibe un `onClick` que dispara la navegaci√≥n.
- Aqu√≠ **no** pasamos el objeto completo por la ruta; pasamos un **id/nombre**.

## 3. √çtem clickeable del men√∫

```kotlin
@Composable
fun PizzaItem(
    pizza: Pizza,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                painter = painterResource(id = pizza.imageRes),
                contentDescription = pizza.type,
                modifier = Modifier.size(80.dp)
            )
            Spacer(Modifier.width(16.dp))
            Column {
                Text(pizza.type, style = MaterialTheme.typography.titleMedium)
                Text(
                    text = "Precio: $${pizza.price}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
        }
    }
}
```

**Puntos clave:**
- `Card` da contenedor con sombra.
- `clickable { onClick() }` separa UI de la acci√≥n (buena pr√°ctica).

## 4. Pantalla de Detalle (recibiendo par√°metro)

```kotlin
@Composable
fun PizzaDetailScreen(
    pizzaName: String?,
    viewModel: PizzaViewModel = viewModel()
) {
    val pizza = remember(pizzaName) { viewModel.findPizzaByName(pizzaName) }

    Scaffold(
        topBar = { TopAppBar(title = { Text("Detalle de ${pizza?.type ?: pizzaName}") }) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            if (pizza != null) {
                Text("Tipo: ${pizza.type}", style = MaterialTheme.typography.titleLarge)
                Spacer(Modifier.height(8.dp))
                Text("Precio: $${pizza.price}")
                Spacer(Modifier.height(8.dp))
                Image(
                    painter = painterResource(id = pizza.imageRes),
                    contentDescription = pizza.type,
                    modifier = Modifier.size(160.dp)
                )
            } else {
                Text("No se encontr√≥ informaci√≥n para '$pizzaName'")
            }
        }
    }
}
```

**Explicaci√≥n:**
En esta funci√≥n `PizzaDetailScreen` se observan varios puntos importantes:

- **Par√°metro de navegaci√≥n:** `pizzaName` llega desde la navegaci√≥n como texto y representa el nombre de la pizza seleccionada en la pantalla anterior.
- **B√∫squeda en el ViewModel:** mediante `viewModel.findPizzaByName(pizzaName)` se busca en la lista de pizzas una coincidencia con ese nombre.
- **Uso de `remember`:** garantiza que la b√∫squeda solo ocurra una vez mientras `pizzaName` no cambie, evitando recomposiciones innecesarias.
- **Estructura visual (`Scaffold`):** organiza la pantalla en una barra superior y un √°rea de contenido. Dentro de ella, `Column` acomoda los elementos de arriba hacia abajo.
- **Contenido mostrado:** se despliegan nombre, precio e imagen de la pizza. Si no se encuentra la pizza, aparece un mensaje informativo para el usuario.
- **Alineaci√≥n centrada:** `horizontalAlignment = Alignment.CenterHorizontally` ubica texto e imagen al centro, manteniendo una presentaci√≥n equilibrada.
- **Patr√≥n arquitect√≥nico:** este ejemplo conecta la **UI declarativa** con los datos del **ViewModel**, manteniendo la l√≥gica del negocio fuera de la vista. As√≠ se obtiene un c√≥digo limpio, reactivo y f√°cil de mantener.

**Notas:**
- La UI pide al `ViewModel` los datos. La UI **no** debe consultar repositorios directamente.
- `mutableStateOf` hace que la UI se recomponga al cambiar el valor.

## 6. Recuperar datos completos en el detalle usando el ViewModel

```kotlin
@Composable
fun PizzaDetailScreen(
    pizzaName: String?,
    viewModel: PizzaViewModel = viewModel()
) {
    val pizza = remember(pizzaName) { viewModel.findPizzaByName(pizzaName) }

    Scaffold(
        topBar = { TopAppBar(title = { Text("Detalle de ${pizza?.type ?: pizzaName}") }) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            if (pizza != null) {
                Text("Tipo: ${pizza.type}", style = MaterialTheme.typography.titleLarge)
                Spacer(Modifier.height(8.dp))
                Text("Precio: $${pizza.price}")
                Spacer(Modifier.height(8.dp))
                Image(
                    painter = painterResource(id = pizza.imageRes),
                    contentDescription = pizza.type,
                    modifier = Modifier.size(160.dp)
                )
            } else {
                Text("No se encontr√≥ informaci√≥n para '$pizzaName'")
            }
        }
    }
}
```

**Clave did√°ctica:**
- Pasamos **solo el nombre** por la ruta; el objeto completo lo reconstruimos desde el `ViewModel`.
- Esto reduce acoplamiento y evita problemas de serializaci√≥n.

## 7. Errores comunes y c√≥mo evitarlos

| Error | Por qu√© ocurre | Soluci√≥n |
|---|---|---|
| Pasar objetos enteros por ruta | Serializaci√≥n fr√°gil, acoplamiento | Pasar solo IDs/nombres y consultar en `ViewModel` |
| Crear un `ViewModel` distinto en cada pantalla cuando comparten datos | Se pierde el estado | Elevar el `ViewModel` al nivel contenedor o usar Hilt para scope adecuado |
| Olvidar `rememberNavController()` | Se recrea el controlador | Siempre usar `rememberNavController()` en la ra√≠z de la app |
| No validar argumentos nulos | Puede crashear | Usar tipos anulables y manejar el caso `null` |

## 8. Resumen
- Compose navega declarativamente con `NavController` + `NavHost`.
- Las pantallas son funciones `@Composable` asociadas a rutas.
- Los argumentos viajan en la **URL** de la ruta y se leen desde `backStackEntry.arguments`.
- El **estado** y los datos deben vivir en el `ViewModel`; la UI observa y reacciona.
- Pasar **identificadores** por la ruta y resolver datos en el `ViewModel` es la pr√°ctica recomendada.

## Referencias
- Navigation Compose: https://developer.android.com/jetpack/compose/navigation
- UDF (Unidirectional Data Flow) en Compose: https://developer.android.com/jetpack/compose/architecture
- Material 3 en Compose: https://developer.android.com/jetpack/compose/themes/material3



### üß† Nota te√≥rica: C√≥mo funciona `remember` y la recomposici√≥n en Compose

`remember` es una funci√≥n que permite **guardar un valor en memoria mientras el Composable est√© activo en la composici√≥n**. Es similar a una variable persistente dentro del ciclo de vida de una funci√≥n `@Composable`.

Cuando Compose vuelve a dibujar (recomponer) la UI porque cambi√≥ alg√∫n estado observado, **las variables normales se reinician**, pero las creadas con `remember` conservan su valor previo. Esto evita que c√°lculos costosos o b√∫squedas (como `findPizzaByName`) se repitan innecesariamente.

Por ejemplo:
```kotlin
val pizza = remember(pizzaName) { viewModel.findPizzaByName(pizzaName) }
```

- Si `pizzaName` no cambia, Compose reutiliza el valor almacenado y **no ejecuta otra vez** la b√∫squeda.
- Si `pizzaName` cambia, `remember` detecta la nueva clave y recalcula el valor.

‚öôÔ∏è **En resumen:**
- `remember` = conserva valores entre recomposiciones.
- Recomposici√≥n = cuando Compose redibuja elementos por cambios en el estado observado.
- Usar `remember` mejora rendimiento y evita trabajo redundante.
