# 📚 8. Persistencia local con Room (Carrito de compras)

## 1-. Objetivos de la clase
- Comprender qué es **Room** y por qué usarlo para **persistir datos** en Android.
- Definir **Entity, DAO y Database** para guardar el **carrito** de la pizzería.
- Integrar Room en **MVVM + Clean Architecture** con un **Repository**.
- Observar datos con **Flow** y mostrarlos en Compose usando `collectAsState()`.
- Implementar operaciones: **agregar**, **incrementar/decrementar cantidad**, **eliminar** y **vaciar** carrito.

> Punto actual: Hasta la clase 7, el carrito vivía solo en memoria (ViewModel). Hoy haremos que **sobreviva** al cerrar la app usando **Room**.

---

## 2-. Preparación del proyecto (Gradle)

```kotlin
// build.gradle.kts (Módulo :app)
plugins {
    id("com.android.application")
    kotlin("android")
    id("com.google.devtools.ksp") // KSP para el compilador de Room
}

dependencies {
    val roomVersion = "2.6.1"
    implementation("androidx.room:room-ktx:$roomVersion")
    ksp("androidx.room:room-compiler:$roomVersion")

    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    implementation("androidx.navigation:navigation-compose:2.7.7")
}
```

**Explicación:** Room es la capa de persistencia oficial de Android, más segura y moderna que usar SQLite directamente. KSP genera el código necesario para las entidades y DAOs.

---

## 3-. Definir la Entity del carrito

```kotlin
@Entity(tableName = "cart_items")
data class CartItemEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0L,
    val pizzaName: String,
    val unitPrice: Double,
    val quantity: Int
)
```

**Explicación:**
- `@Entity` marca la clase como tabla de Room (una tabla física en SQLite).
- Cada propiedad se convierte en una columna; los tipos soportan conversión automática a SQLite.
- `@PrimaryKey(autoGenerate = true)` delega en Room la generación del identificador único cada vez que se inserta un registro.
- Este entity representa la fila mínima para reconstruir un elemento del carrito: sabemos qué pizza es (`pizzaName`), cuánto cuesta (`unitPrice`) y cuántas unidades tiene (`quantity`). Añadir la `id` facilita actualizar o eliminar un ítem concreto.

---

## 4-. Definir el DAO (Data Access Object)

```kotlin
@Dao
interface CartDao {
    @Query("SELECT * FROM cart_items ORDER BY id DESC")
    fun observeCart(): Flow<List<CartItemEntity>>

    @Query("SELECT * FROM cart_items WHERE id = :id")
    suspend fun findById(id: Long): CartItemEntity?

    @Query("SELECT * FROM cart_items WHERE pizzaName = :pizzaName LIMIT 1")
    suspend fun findByName(pizzaName: String): CartItemEntity?

    @Upsert
    suspend fun upsert(item: CartItemEntity)

    @Delete
    suspend fun delete(item: CartItemEntity)

    @Query("DELETE FROM cart_items")
    suspend fun clear()
}
```

**Explicación:** DAO (siglas de **Data Access Object**) es el contrato que traduce llamadas Kotlin a sentencias SQL. Room genera la implementación en tiempo de compilación:
- `observeCart()` devuelve un `Flow`, así la UI recibe actualizaciones cuando cambian los datos.
- `findById()` y `findByName()` permiten obtener registros concretos para editar o reutilizar.
- `upsert()` inserta o actualiza según exista ya la fila; `delete()` elimina una fila precisa y `clear()` borra toda la tabla.
- Separar la lógica en este DAO mantiene centralizadas las consultas y evita escribir SQL manual repetido.

---

## 5-. Definir la base de datos Room

```kotlin
@Database(entities = [CartItemEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun cartDao(): CartDao

    companion object {
        @Volatile private var INSTANCE: AppDatabase? = null
        fun getInstance(context: Context): AppDatabase =
            INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "pizzeria-db"
                ).build().also { INSTANCE = it }
            }
    }
}
```

**Explicación:** `Room.databaseBuilder` crea la base de datos en almacenamiento interno. Usamos patrón Singleton para una única instancia.

---

## 6-. Repository (capa de dominio de la app)

```kotlin
class CartRepositoryImpl(private val dao: CartDao) {
    fun observeCart() = dao.observeCart()
    suspend fun addPizza(name: String, price: Double) {
        dao.upsert(CartItemEntity(pizzaName = name, unitPrice = price, quantity = 1))
    }
    suspend fun incrementQuantity(id: Long) {
        dao.findById(id)?.let { dao.upsert(it.copy(quantity = it.quantity + 1)) }
    }
    suspend fun decrementQuantity(id: Long) {
        dao.findById(id)?.let { entity ->
            val updated = entity.quantity - 1
            if (updated > 0) dao.upsert(entity.copy(quantity = updated)) else dao.delete(entity)
        }
    }
    suspend fun removeItem(id: Long) {
        dao.findById(id)?.let(dao::delete)
    }
    suspend fun clearCart() = dao.clear()
}
```

**Explicación:** El repositorio aísla la lógica de acceso a datos y aplica reglas de negocio:
- `observeCart()` transforma la lista de entidades a objetos de dominio (`CartItem`) que puede consumir la UI.
- `addPizza()` reutiliza una fila existente si ya había una pizza con el mismo nombre, incrementando la cantidad.
- `incrementQuantity()`, `decrementQuantity()` y `removeItem()` encapsulan la manipulación de cantidades y eliminaciones sin que la UI conozca detalles de Room.
- `clearCart()` borra todo el carrito en una sola operación. Así, el resto de capas siguen hablando en términos de dominio y no de base de datos.

---

## 7-. ViewModel del carrito persistente

```kotlin
class CartViewModel(private val repository: CartRepositoryImpl) : ViewModel() {
    val cartItems: StateFlow<List<CartItemEntity>> = repository.observeCart().stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )
    val cartCount: StateFlow<Int> = cartItems
        .map { list -> list.sumOf { it.quantity } }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = 0
        )

    fun addPizza(name: String, price: Double) = viewModelScope.launch {
        repository.addPizza(name, price)
    }

    fun incrementQuantity(id: Long) = viewModelScope.launch {
        repository.incrementQuantity(id)
    }

    fun decrementQuantity(id: Long) = viewModelScope.launch {
        repository.decrementQuantity(id)
    }

    fun removeItem(id: Long) = viewModelScope.launch {
        repository.removeItem(id)
    }

    fun clearCart() = viewModelScope.launch { repository.clearCart() }
}
```

**Explicación:** En Kotlin, `Flow` es un flujo asíncrono que emite valores continuamente cuando cambian los datos. En el ViewModel:
- `cartItems` se convierte en `StateFlow` mediante `stateIn`, reteniendo el último estado y compartiéndolo entre las pantallas mientras exista el `viewModelScope`.
- `cartCount` deriva del flujo anterior, calculando la suma de cantidades para mostrar un badge en la UI.
- Las funciones `addPizza`, `incrementQuantity`, `decrementQuantity`, `removeItem` y `clearCart` lanzan corrutinas en `viewModelScope`, garantizando que el trabajo con Room se haga fuera del hilo de UI.
- Centralizar estas operaciones mantiene el estado consistente (si varias pantallas usan el mismo ViewModel, comparten las mismas actualizaciones).

---

## 8-. Integración en la app (obtener DB, Repo y ViewModel)

```kotlin
@Composable
fun PizzeriaApp() {
    val context = LocalContext.current
    val navController = rememberNavController()
    val pizzaViewModel: PizzaViewModel = viewModel()
    val database = remember { AppDatabase.getInstance(context) }
    val repository = remember { CartRepositoryImpl(database.cartDao()) }
    val cartViewModel: CartViewModel = viewModel(
        factory = object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                @Suppress("UNCHECKED_CAST")
                return CartViewModel(repository) as T
            }
        }
    )

    NavHost(navController = navController, startDestination = "menu") {
        composable("menu") {
            MenuScreen(
                navController = navController,
                pizzaViewModel = pizzaViewModel,
                cartViewModel = cartViewModel
            )
        }
        composable("detalle/{pizzaName}") { backStackEntry ->
            val pizzaName = backStackEntry.arguments?.getString("pizzaName")
            PizzaDetailScreen(
                pizzaName = pizzaName,
                pizzaViewModel = pizzaViewModel,
                cartViewModel = cartViewModel,
                navController = navController
            )
        }
        composable("carrito") {
            CartScreen(
                cartViewModel = cartViewModel,
                navController = navController
            )
        }
    }
}
```

**Explicación:** Aquí se inicializa la cadena completa de dependencias y se comparte un mismo ViewModel entre pantallas:
- `AppDatabase.getInstance(context)` obtiene (o crea) la base de datos Singleton; `remember` evita reconstrucciones en recomposiciones.
- `CartRepositoryImpl` se construye una vez con el DAO; si mañana cambiara la fuente de datos, solo el repositorio se modificaría.
- La `Factory` manual permite inyectar el repositorio al `CartViewModel`, cumpliendo con MVVM sin frameworks externos.
- `NavHost` recibe los dos ViewModels (`PizzaViewModel` y `CartViewModel`) y los pasa a cada destino para que la navegación siempre use el mismo estado compartido.

---

## 9-. Usar Room desde las pantallas (Compose)

### Menú
```kotlin
@Composable
fun CartScreen(viewModel: CartViewModel, navController: NavController) {
    val cart by viewModel.cartItems.collectAsState()
    val count by viewModel.cartCount.collectAsState()
    val total = cart.sumOf { it.unitPrice * it.quantity }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("🛒 Carrito ($count)") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = null)
                    }
                },
                actions = {
                    if (cart.isNotEmpty()) {
                        IconButton(onClick = { viewModel.clearCart() }) {
                            Icon(Icons.Default.Delete, contentDescription = null)
                        }
                    }
                }
            )
        }
    ) { padding ->
        if (cart.isEmpty()) {
            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text("El carrito está vacío 😢")
            }
        } else {
            LazyColumn(
                modifier = Modifier.padding(padding).fillMaxSize(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(cart, key = { it.id }) { item ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(item.pizzaName, style = MaterialTheme.typography.titleMedium)
                            Text("x${item.quantity}  —  $${"%.2f".format(item.unitPrice * item.quantity)}")
                        }
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            IconButton(onClick = { viewModel.decrementQuantity(item.id) }) {
                                Icon(Icons.Default.Remove, contentDescription = "Menos")
                            }
                            Text("${item.quantity}")
                            IconButton(onClick = { viewModel.incrementQuantity(item.id) }) {
                                Icon(Icons.Default.Add, contentDescription = "Más")
                            }
                            IconButton(onClick = { viewModel.removeItem(item.id) }) {
                                Icon(Icons.Default.Delete, contentDescription = "Eliminar")
                            }
                        }
                    }
                }
                item {
                    Text(
                        text = "Total: $${"%.2f".format(total)}",
                        modifier = Modifier.padding(16.dp)
                    )
                }
            }
        }
    }
}
```

**Explicación:** Cada cambio en la base de datos genera automáticamente una recomposición, actualizando el listado del carrito:
- `collectAsState()` convierte los `StateFlow` en estado Compose reactivo, de modo que cualquier inserción o borrado refresca la UI instantáneamente.
- La `TopAppBar` usa `cartCount` para mostrar el número total de pizzas; los botones usan `viewModel.clearCart()` y `navController.popBackStack()` para navegar sin duplicar lógica.
- La lista (`LazyColumn`) visualiza cada ítem con subtotal y controles de cantidad. Los botones de `+`, `-` y `Eliminar` llaman a las funciones correspondientes del ViewModel, que a su vez modifican Room.
- El total se calcula sumando `unitPrice * quantity` y se muestra al final como resumen de compra. De esta forma, toda la interacción queda cubierta sin acceder directamente a la base de datos desde la UI.

---

## 10-. Cómo encaja en MVVM + Clean Architecture

| Capa | Responsabilidad |
|---|---|
| UI (Compose) | Muestra datos y eventos de usuario |
| ViewModel | Coordina flujo de datos y estado |
| Repository | Gestiona acceso a datos (Room) |
| Room | Persistencia real local |

---

## 11-. Errores comunes y cómo evitarlos

| Error | Causa | Solución |
|---|---|---|
| No agregar KSP | Room no genera código | Agrega el plugin `com.google.devtools.ksp` |
| Bloquear la UI | Llamadas a Room fuera de corrutinas | Usa `viewModelScope.launch` |
| No observar cambios | No usar Flow | Usa `Flow` + `collectAsState()` |

---

## 12-. Resumen de la clase
- Implementamos **Room** para persistir datos.
- Definimos **Entity, DAO y Database**.
- Conectamos con **Repository** y **ViewModel**.
- La app ahora guarda el carrito incluso tras cerrar la app.

---

## 13-. Referencias
- [Room oficial](https://developer.android.com/training/data-storage/room)
- [Compose + Flow](https://developer.android.com/jetpack/compose/architecture#viewmodel-state)
