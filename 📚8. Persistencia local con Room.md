# 📚 8. Persistencia local con Room (Carrito de compras)

## 1-. Objetivos de la clase
- Comprender qué es **Room** y por qué usarlo para **persistir datos** en Android.
- Definir **Entity, DAO y Database** para guardar el **carrito** de la pizzería.
- Integrar Room en **MVVM + Clean Architecture** con un **Repository**.
- Observar datos con **Flow** y mostrarlos en Compose usando `collectAsState()`.
- Implementar operaciones: **agregar**, **incrementar/decrementar cantidad**, **eliminar** y **vaciar** carrito.

> Punto actual: Hasta la clase 7, el carrito vivía solo en memoria (ViewModel). Hoy haremos que **sobreviva** al cerrar la app usando **Room**.

---

## 2-. Preparación del proyecto (Gradle)

Para usar Room y KSP, necesitamos añadir las dependencias y plugins correspondientes en nuestros archivos de Gradle.

**1. Define las versiones en `gradle/libs.versions.toml`:**

```toml
[versions]
# ... (otras versiones)
ksp = "2.0.21-1.0.25"
room = "2.6.1"

[libraries]
# ... (otras librerías)
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "room" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "room" }

[plugins]
# ... (otros plugins)
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
```

**2. Aplica el plugin y las dependencias en `app/build.gradle.kts`:**

```kotlin
plugins {
    // ... (otros plugins)
    alias(libs.plugins.ksp)
}

dependencies {
    // ... (otras dependencias)
    implementation(libs.androidx.room.ktx)
    ksp(libs.androidx.room.compiler)
}
```

**Explicación:** Room es la capa de persistencia oficial de Android. KSP (`Kotlin Symbol Processing`) es la herramienta que Room usa para generar el código necesario para las `Entities` y `DAOs` en tiempo de compilación, evitando el uso de `reflection` y mejorando el rendimiento.

---

## 3-. Definir la Entity del carrito

```kotlin
@Entity(tableName = "cart_items")
data class CartItemEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0L,
    val pizzaName: String,
    val unitPrice: Double,
    val quantity: Int
)
```

**Explicación:**
- `@Entity` marca la clase como tabla de Room (una tabla física en SQLite).
- Cada propiedad se convierte en una columna; los tipos soportan conversión automática a SQLite.
- `@PrimaryKey(autoGenerate = true)` delega en Room la generación del identificador único cada vez que se inserta un registro.
- Este entity representa la fila mínima para reconstruir un elemento del carrito: sabemos qué pizza es (`pizzaName`), cuánto cuesta (`unitPrice`) y cuántas unidades tiene (`quantity`). Añadir la `id` facilita actualizar o eliminar un ítem concreto.

---

## 4-. Definir el DAO (Data Access Object)

```kotlin
@Dao
interface CartDao {
    @Query("SELECT * FROM cart_items ORDER BY id DESC")
    fun observeCart(): Flow<List<CartItemEntity>>

    @Query("SELECT * FROM cart_items WHERE id = :id")
    suspend fun findById(id: Long): CartItemEntity?

    @Query("SELECT * FROM cart_items WHERE pizzaName = :pizzaName LIMIT 1")
    suspend fun findByName(pizzaName: String): CartItemEntity?

    @Upsert
    suspend fun upsert(item: CartItemEntity)

    @Delete
    suspend fun delete(item: CartItemEntity)

    @Query("DELETE FROM cart_items")
    suspend fun clear()
}
```

**Explicación:** DAO (siglas de **Data Access Object**) es el contrato que traduce llamadas Kotlin a sentencias SQL. Room genera la implementación en tiempo de compilación:
- `observeCart()` devuelve un `Flow`, así la UI recibe actualizaciones cuando cambian los datos.
- `findById()` y `findByName()` permiten obtener registros concretos para editar o reutilizar.
- `upsert()` inserta o actualiza según exista ya la fila; `delete()` elimina una fila precisa y `clear()` borra toda la tabla.
- Separar la lógica en este DAO mantiene centralizadas las consultas y evita escribir SQL manual repetido.

---

## 5-. Definir la base de datos Room

```kotlin
@Database(entities = [CartItemEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun cartDao(): CartDao

    companion object {
        @Volatile private var INSTANCE: AppDatabase? = null
        fun getInstance(context: Context): AppDatabase =
            INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "pizzeria-db"
                ).build().also { INSTANCE = it }
            }
    }
}
```

**Explicación:** `Room.databaseBuilder` crea la base de datos en almacenamiento interno. Usamos patrón Singleton para una única instancia.

---

## 6-. Repository (capa de dominio de la app)

```kotlin
class CartRepositoryImpl(private val dao: CartDao) {
    fun observeCart() = dao.observeCart()
    suspend fun addPizza(name: String, price: Double) {
        dao.upsert(CartItemEntity(pizzaName = name, unitPrice = price, quantity = 1))
    }
    suspend fun incrementQuantity(id: Long) {
        dao.findById(id)?.let { dao.upsert(it.copy(quantity = it.quantity + 1)) }
    }
    suspend fun decrementQuantity(id: Long) {
        dao.findById(id)?.let { entity ->
            val updated = entity.quantity - 1
            if (updated > 0) dao.upsert(entity.copy(quantity = updated)) else dao.delete(entity)
        }
    }
    suspend fun removeItem(id: Long) {
        dao.findById(id)?.let { dao.delete(it) }
    }
    suspend fun clearCart() = dao.clear()
}
```

**Explicación:** El repositorio aísla la lógica de acceso a datos y aplica reglas de negocio:
- `observeCart()` transforma la lista de entidades a objetos de dominio (`CartItem`) que puede consumir la UI.
- `addPizza()` reutiliza una fila existente si ya había una pizza con el mismo nombre, incrementando la cantidad.
- `incrementQuantity()`, `decrementQuantity()` y `removeItem()` encapsulan la manipulación de cantidades y eliminaciones sin que la UI conozca detalles de Room.
- `clearCart()` borra todo el carrito en una sola operación. Así, el resto de capas siguen hablando en términos de dominio y no de base de datos.

---

## 7-. ViewModel del carrito persistente

```kotlin
class CartViewModel(private val repository: CartRepositoryImpl) : ViewModel() {
    val cartItems: StateFlow<List<CartItemEntity>> = repository.observeCart().stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )
    val cartCount: StateFlow<Int> = cartItems
        .map { list -> list.sumOf { it.quantity } }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = 0
        )

    fun addPizza(name: String, price: Double) = viewModelScope.launch {
        repository.addPizza(name, price)
    }

    fun incrementQuantity(id: Long) = viewModelScope.launch {
        repository.incrementQuantity(id)
    }

    fun decrementQuantity(id: Long) = viewModelScope.launch {
        repository.decrementQuantity(id)
    }

    fun removeItem(id: Long) = viewModelScope.launch {
        repository.removeItem(id)
    }

    fun clearCart() = viewModelScope.launch { repository.clearCart() }
}
```

**Explicación:** En Kotlin, `Flow` es un flujo asíncrono que emite valores continuamente cuando cambian los datos. En el ViewModel:
- `cartItems` se convierte en `StateFlow` mediante `stateIn`, reteniendo el último estado y compartiéndolo entre las pantallas mientras exista el `viewModelScope`.
- `cartCount` deriva del flujo anterior, calculando la suma de cantidades para mostrar un badge en la UI.
- Las funciones `addPizza`, `incrementQuantity`, `decrementQuantity`, `removeItem` y `clearCart` lanzan corrutinas en `viewModelScope`, garantizando que el trabajo con Room se haga fuera del hilo de UI.
- Centralizar estas operaciones mantiene el estado consistente (si varias pantallas usan el mismo ViewModel, comparten las mismas actualizaciones).

---

## 8-. Integración en la app (obtener DB, Repo y ViewModel)

```kotlin
@Composable
fun PizzeriaApp() {
    val context = LocalContext.current
    val navController = rememberNavController()
    val pizzaViewModel: PizzaViewModel = viewModel()
    val database = remember { AppDatabase.getInstance(context) }
    val repository = remember { CartRepositoryImpl(database.cartDao()) }
    val cartViewModel: CartViewModel = viewModel(
        factory = object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                @Suppress("UNCHECKED_CAST")
                return CartViewModel(repository) as T
            }
        }
    )

    NavHost(navController = navController, startDestination = "menu") {
        composable("menu") {
            MenuScreen(
                navController = navController,
                pizzaViewModel = pizzaViewModel,
                cartViewModel = cartViewModel
            )
        }
        composable("detalle/{pizzaName}") { backStackEntry ->
            val pizzaName = backStackEntry.arguments?.getString("pizzaName")
            PizzaDetailScreen(
                pizzaName = pizzaName,
                pizzaViewModel = pizzaViewModel,
                cartViewModel = cartViewModel,
                navController = navController
            )
        }
        composable("carrito") {
            CartScreen(
                cartViewModel = cartViewModel,
                navController = navController
            )
        }
    }
}
```

**Explicación:** Aquí se inicializa la cadena completa de dependencias y se comparte un mismo ViewModel entre pantallas:
- `AppDatabase.getInstance(context)` obtiene (o crea) la base de datos Singleton; `remember` evita reconstrucciones en recomposiciones.
- `CartRepositoryImpl` se construye una vez con el DAO; si mañana cambiara la fuente de datos, solo el repositorio se modificaría.
- La `Factory` manual permite inyectar el repositorio al `CartViewModel`, cumpliendo con MVVM sin frameworks externos.
- `NavHost` recibe los dos ViewModels (`PizzaViewModel` y `CartViewModel`) y los pasa a cada destino para que la navegación siempre use el mismo estado compartido.

---

## 9-. Usar Room desde las pantallas (Compose)

### MenuScreen

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MenuScreen(
    navController: NavController,
    pizzaViewModel: PizzaViewModel,
    cartViewModel: CartViewModel
) {
    val pizzas = pizzaViewModel.pizzaList
    val cartCount by cartViewModel.cartCount.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("🍕 Menú de Pizzas") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary
                ),
                actions = {
                    IconButton(onClick = { navController.navigate("carrito") }) {
                        BadgedBox(
                            badge = {
                                if (cartCount > 0) {
                                    Badge { Text("$cartCount") }
                                }
                            }
                        ) {
                            Icon(
                                imageVector = Icons.Filled.ShoppingCart,
                                contentDescription = "Ver carrito"
                            )
                        }
                    }
                }
            )
        },
        containerColor = MaterialTheme.colorScheme.background
    ) { padding ->
        LazyColumn(
            contentPadding = padding,
            verticalArrangement = Arrangement.spacedBy(12.dp),
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 16.dp, vertical = 12.dp)
        ) {
```

**Explicación de los cambios:**
- **ViewModels separados:** `MenuScreen` ahora recibe `pizzaViewModel` y `cartViewModel` por separado, en lugar de un único ViewModel, para separar responsabilidades.
- **Contador de carrito reactivo:** El contador del carrito (`cartCount`) ahora se obtiene de `cartViewModel.cartCount.collectAsState()`. Esto asegura que el número en el ícono del carrito se actualice automáticamente cuando los datos cambian en la base de datos.
- **Navegación al carrito:** El botón del carrito en la `TopAppBar` ahora usa `navController.navigate("carrito")` para ir a la pantalla del carrito.


**Explicación:** Cada cambio en la base de datos genera automáticamente una recomposición, actualizando el listado del carrito:
- `collectAsState()` convierte los `StateFlow` en estado Compose reactivo, de modo que cualquier inserción o borrado refresca la UI instantáneamente.
- La `TopAppBar` usa `cartCount` para mostrar el número total de pizzas; los botones usan `viewModel.clearCart()` y `navController.popBackStack()` para navegar sin duplicar lógica.
- La lista (`LazyColumn`) visualiza cada ítem con subtotal y controles de cantidad. Los botones de `+`, `-` y `Eliminar` llaman a las funciones correspondientes del ViewModel, que a su vez modifican Room.
- El total se calcula sumando `unitPrice * quantity` y se muestra al final como resumen de compra. De esta forma, toda la interacción queda cubierta sin acceder directamente a la base de datos desde la UI.

---

### PizzaDetailScreen

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PizzaDetailScreen(
    pizzaName: String?,
    pizzaViewModel: PizzaViewModel,
    cartViewModel: CartViewModel,
    navController: NavController
) {
    val pizza = pizzaViewModel.findPizzaByName(pizzaName)
    val cartCount by cartViewModel.cartCount.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Detalle de ${pizza?.type ?: pizzaName}") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,
                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary
                ),
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.Filled.ArrowBack,
                            contentDescription = "Volver"
                        )
                    }
                },
                actions = {
                    IconButton(onClick = { navController.navigate("carrito") }) {
                        BadgedBox(
                            badge = {
                                if (cartCount > 0) {
                                    Badge { Text("$cartCount") }
                                }
                            }
                        ) {
                            Icon(
                                imageVector = Icons.Filled.ShoppingCart,
                                contentDescription = "Ir al carrito"
                            )
                        }
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) },
        containerColor = MaterialTheme.colorScheme.background
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            if (pizza != null) {
                Image(
                    painter = painterResource(id = pizza.imageRes),
                    contentDescription = pizza.type,
                    modifier = Modifier.size(160.dp)
                )
                Text(text = "Precio: ${pizza.price}")
                Button(onClick = {
                    cartViewModel.addPizza(pizza.type, pizza.price)
                    scope.launch { snackbarHostState.showSnackbar("Pizza agregada al carrito") }
                }) {
                                    Text("Agregar al carrito 🛒")
                                }
                                } else {
                                    Text("No se encontró información para '$pizzaName'")
                                }
                            }
                        }
                    }
                    
                    **Explicación de los cambios:**
                    - **Uso de `cartViewModel`:** Al igual que `MenuScreen`, esta pantalla ahora recibe y utiliza `cartViewModel` para interactuar con el carrito.
                    - **Añadir al carrito:** El botón "Agregar al carrito" ahora llama a `cartViewModel.addPizza(pizza.type, pizza.price)`, que encapsula la lógica de añadir un ítem a la base de datos a través del repositorio.
                    - **Badge en el ícono del carrito:** Se reutiliza el `BadgedBox` para mostrar el contador de ítems en el ícono del carrito, manteniendo la consistencia con la pantalla de menú.```

### CartScreen

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CartScreen(
    cartViewModel: CartViewModel,
    navController: NavController
) {
    val cartItems by cartViewModel.cartItems.collectAsState()
    val cartCount = cartItems.sumOf { it.quantity }
    val total = cartItems.sumOf { it.unitPrice * it.quantity }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("🛒 Carrito ($cartCount)") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,
                    actionIconContentColor = MaterialTheme.colorScheme.onPrimary
                ),
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.Filled.ArrowBack,
                            contentDescription = "Volver"
                        )
                    }
                },
                actions = {
                    if (cartItems.isNotEmpty()) {
                        IconButton(onClick = { cartViewModel.clearCart() }) {
                            Icon(
                                imageVector = Icons.Filled.Delete,
                                contentDescription = "Vaciar carrito"
                            )
                        }
                    }
                }
            )
        },
        containerColor = MaterialTheme.colorScheme.background
    ) { padding ->
        if (cartItems.isEmpty()) {
            Box(
                modifier = Modifier
                    .padding(padding)
                    .fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Text("El carrito está vacío 😢")
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .padding(padding)
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(cartItems, key = { it.id }) { item ->
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            Column {
                                Text(text = item.pizzaName, style = MaterialTheme.typography.titleMedium)
                                Text(text = "Precio unitario: ${item.unitPrice}")
                                Text(text = "Subtotal: ${"%.2f".format(item.unitPrice * item.quantity)}")
                            }
                            Spacer(modifier = Modifier.weight(1f))
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                IconButton(onClick = { cartViewModel.decrementQuantity(item.id) }) {
                                    Icon(
                                        imageVector = Icons.Filled.Remove,
                                        contentDescription = "Reducir cantidad"
                                    )
                                }
                                Text(text = "${item.quantity}")
                                IconButton(onClick = { cartViewModel.incrementQuantity(item.id) }) {
                                    Icon(
                                        imageVector = Icons.Filled.Add,
                                        contentDescription = "Incrementar cantidad"
                                    )
                                }
                                IconButton(onClick = { cartViewModel.removeItem(item.id) }) {
                                    Icon(
                                        imageVector = Icons.Filled.Delete,
                                        contentDescription = "Eliminar"
                                    )
                                }
                            }
                        }
                    }
                }
                item {
                    Spacer(modifier = Modifier.padding(4.dp))
                    Text(
                        text = "Total a pagar: ${"%.2f".format(total)}",
                        style = MaterialTheme.typography.titleMedium,
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            }
        }
    }
}
```

---

---

**Explicación de los cambios:**
- **Fuente de datos reactiva:** La pantalla ahora solo recibe `cartViewModel` y obtiene de él la lista `cartItems` y el `cartCount` como un `State` de Compose. Esto significa que la UI reaccionará automáticamente a cualquier cambio en la base de datos.
- **Interacciones con el ViewModel:** Todas las acciones (incrementar, decrementar, eliminar ítem y vaciar carrito) ahora se delegan a las funciones correspondientes en `cartViewModel`. La UI ya no tiene lógica de negocio.
- **Cálculo del total:** El precio total se calcula en la propia pantalla a partir de la lista de `cartItems`, asegurando que siempre refleje el estado actual del carrito.
- **Uso de `key` en `LazyColumn`:** Se añade un `key` a la lista de ítems (`key = { it.id }`) para mejorar el rendimiento y evitar recomposiciones innecesarias cuando la lista cambia.

---

## 10-. Cómo encaja en MVVM + Clean Architecture

| Capa | Responsabilidad |
|---|---|
| UI (Compose) | Muestra datos y eventos de usuario |
| ViewModel | Coordina flujo de datos y estado |
| Repository | Gestiona acceso a datos (Room) |
| Room | Persistencia real local |

---

## 11-. Errores comunes y cómo evitarlos

| Error | Causa | Solución |
|---|---|---|
| No agregar KSP | Room no genera código | Agrega el plugin `com.google.devtools.ksp` |
| Bloquear la UI | Llamadas a Room fuera de corrutinas | Usa `viewModelScope.launch` |
| No observar cambios | No usar Flow | Usa `Flow` + `collectAsState()` |

---

## 12-. Resumen de la clase
- Implementamos **Room** para persistir datos.
- Definimos **Entity, DAO y Database**.
- Conectamos con **Repository** y **ViewModel**.
- La app ahora guarda el carrito incluso tras cerrar la app.

---

## 13-. Referencias
- [Room oficial](https://developer.android.com/training/data-storage/room)
- [Compose + Flow](https://developer.android.com/jetpack/compose/architecture#viewmodel-state)
